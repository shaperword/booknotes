date  显示系统当前时间和日期

cal     显示当前月份的日历

df	  查看磁盘空间

free	  显示内存空间

exit    结束终端会话

Ctrl-Alt-F1 到 Ctrl-Alt-F6 对应1-6个终端，Alt-F1到Alt-F6可在终端来回切换，Alt-F7返回图形界面

pwd - Print name of current working directory   打印当前工作目录名

cd - Change directory  改变目录

ls - List directory contents  列出目录内容

. 指工作目录  .. 指工作目录的父目录   ./默认可以省略

cd 更改目录到你的home目录

cd - 更改工作目录到先前的工作目录

cd ~ username   更改工作目录到用户家目录

ls -a  可以查看隐藏文件  .字符开头的文件名是隐藏文件

ls可罗列多个内容 比如 ls ~ /usr 会显示home和 /usr两个目录的文件

ls -l 中的-l 是以长模式输出的意思

ls -t 是以修改时间的先后来排序

ls -lt --reverse  结果以反向输出 --reverse是长选项



| 选项 | 长选项           | 描述                                                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| -a   | --all            | 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 |
| -d   | --directory      | 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 |
| -F   | --classify       | 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 |
| -h   | --human-readable | 当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。 |
| -l   |                  | 以长格式显示结果。                                           |
| -r   | --reverse        | 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 |
| -S   |                  | 命令输出结果按照文件大小来排序。                             |
| -t   |                  | 按照修改时间来排序。                                         |

```bash
-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg
```

字段含义-rw-r--r--对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。1文件的硬链接数目。root文件所有者的用户名。root文件所属用户组的名字。32059以字节数表示的文件大小。2007-04-03 11:05上次修改文件的时间和日期。oo-cd-cover.odf文件名。  

file filename  file命令会打印出文件内容的简单描述

less filename  less常命令用来看日志

| 命令               | 行为                                                     |
| ------------------ | -------------------------------------------------------- |
| Page UP or b       | 向上翻滚一页                                             |
| Page Down or space | 向下翻滚一页                                             |
| UP Arrow           | 向上翻滚一行                                             |
| Down Arrow         | 向下翻滚一行                                             |
| G                  | 移动到最后一行                                           |
| 1G or g            | 移动到开头一行                                           |
| /charaters         | 向前查找指定的字符串                                     |
| n                  | 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 |
| h                  | 显示帮助屏幕                                             |
| q                  | 退出 less 程序                                           |



| 目录           | 评论                                                         |
| -------------- | ------------------------------------------------------------ |
| /              | 根目录，万物起源。                                           |
| /bin           | 包含系统启动和运行所必须的二进制程序。                       |
| /boot          | 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 |
| /dev           | 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 |
| /etc           | 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 |
| /home          | 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 |
| /lib           | 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 |
| /lost+found    | 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 |
| /media         | 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 |
| /mnt           | 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。     |
| /opt           | 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 |
| /proc          | 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 |
| /root          | root 帐户的家目录。                                          |
| /sbin          | 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 |
| /tmp           | 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 |
| /usr           | 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 |
| /usr/bin       | /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 |
| /usr/lib       | 包含由/usr/bin 目录中的程序所用的共享库。                    |
| /usr/local     | 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 |
| /usr/sbin      | 包含许多系统管理程序。                                       |
| /usr/share     | /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 |
| /usr/share/doc | 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 |
| /var           | 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 |
| /var/log       | 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 |



符号链接

硬链接



cp – Copy files and directories  复制文件和目录  

mv – Move/rename files and directories  移动/重命名文件和目录 

mkdir – Create directories  创建目录 

rm – Remove files and directories  删除文件和目录 

ln – Create hard and symbolic links   创建硬链接和符号链接 



| 通配符        | 意义                               |
| ------------- | ---------------------------------- |
| *             | 匹配任意多个字符（包括零个或一个） |
| ?             | 匹配任意一个字符（不包括零个）     |
| [characters]  | 匹配任意一个属于字符集中的字符     |
| [!characters] | 匹配任意一个不是字符集中的字符     |
| [[:class:]]   | 匹配任意一个属于指定字符类中的字符 |

| 字符类    | 意义                   |
| --------- | ---------------------- |
| [:alnum:] | 匹配任意一个字母或数字 |
| [:alpha:] | 匹配任意一个字母       |
| [:digit:] | 匹配任意一个数字       |
| [:lower:] | 匹配任意一个小写字母   |
| [:upper:] | 匹配任意一个大写字母   |

| 模式                   | 匹配对象                                                  |
| ---------------------- | --------------------------------------------------------- |
| *                      | 所有文件                                                  |
| g*                     | 文件名以“g”开头的文件                                     |
| b*.txt                 | 以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件 |
| Data???                | 以“Data”开头，其后紧接着3个字符的文件                     |
| [abc]*                 | 文件名以"a","b",或"c"开头的文件                           |
| BACKUP.[0-9][0-9][0-9] | 以"BACKUP."开头，并紧接着3个数字的文件                    |
| [[:upper:]]*           | 以大写字母开头的文件                                      |
| [![:digit:]]*          | 不以数字开头的文件                                        |
| *[[:lower:]123]        | 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件    |

如果你用过别的类 Unix 系统的操作环境，或者是读过这方面的书籍，你可能遇到过[A-Z]或 [a-z]形式的字符范围表示法。这些都是传统的 Unix 表示法，并且在早期的 Linux 版本中仍有效。 虽然它们仍然起作用，但是你必须小心地使用它们，因为它们不会产生你期望的输出结果，除非 你合理地配置它们。从现在开始，你应该避免使用它们，并且用字符类来代替它们。 



mkdir directory...   ...三个点表示此参数可以重复

```
mkdir dir1 dir2 dir3
```

创建三个文件



```
cp item1 item2
```

复制单个文件或目录”item1”到文件或目录”item2” 



```
cp item... directory
```

复制多个项目（文件或目录）到一个目录下。 



| 选项              | 意义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -a, --archive     | 复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。 |
| -i, --interactive | 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 |
| -r, --recursive   | 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。 |
| -u, --update      | 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 |
| -v, --verbose     | 显示翔实的命令操作信息                                       |

| 命令                | 运行结果                                                     |
| ------------------- | ------------------------------------------------------------ |
| cp file1 file2      | 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。 |
| cp -i file1 file2   | 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。 |
| cp file1 file2 dir1 | 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 |
| cp dir1/* dir2      | 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 |
| cp -r dir1 dir2     | 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。 |

```
mv item1 item2
```

把文件或目录 “item1” 移动或重命名为 “item2” 

```
mv item... directory
```

把一个或多个条目从一个目录移动到另一个目录中。 



| 选项             | 意义                                                         |
| ---------------- | ------------------------------------------------------------ |
| -i --interactive | 在重写一个已经存在的文件之前，提示用户确认信息。 **如果不指定这个选项，mv 命令会默认重写文件内容。** |
| -u --update      | 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。 |
| -v --verbose     | 当操作 mv 命令时，显示翔实的操作信息。                       |

| mv file1 file2      | 移动 file1 到 file2。**如果 file2 存在，它的内容会被 file1 的内容重写。** 如果 file2 不存在，则创建 file2。 **这两种情况下，file1 都不再存在。** |
| ------------------- | ------------------------------------------------------------ |
| mv -i file1 file2   | 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。 |
| mv file1 file2 dir1 | 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。      |
| mv dir1 dir2        | 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。 |

```
rm item...
```

| 选项              | 意义                                                         |
| ----------------- | ------------------------------------------------------------ |
| -i, --interactive | 在删除已存在的文件前，提示用户确认信息。 **如果不指定这个选项，rm 会默默地删除文件** |
| -r, --recursive   | 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 |
| -f, --force       | 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。 |
| -v, --verbose     | 在执行 rm 命令时，显示翔实的操作信息。                       |

| 命令              | 运行结果                                                     |
| ----------------- | ------------------------------------------------------------ |
| rm file1          | 默默地删除文件                                               |
| rm -i file1       | 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。 |
| rm -r file1 dir1  | 删除文件 file1, 目录 dir1，及 dir1 中的内容。                |
| rm -rf file1 dir1 | 同上，除非文件 file1或目录 dir1 不存在，否则rm 仍会继续执行。 |



ln 创建链接

ln file link   创建硬链接

ln -s item link  创建符号链接，item可以是一个文件或是一个目录

硬链接

与更加现代的符号链接相比，硬链接是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接， 这个硬链接给予文件名字。我们每创建一个硬链接，就为一个文件创建了一个额外的目录项。 硬链接有两个重要局限性： 

1. 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。
2. 一个硬链接不能关联一个目录。

一个硬链接和文件本身没有什么区别。不像符号链接，当你列出一个包含硬链接的目录 内容时，你会看到没有特殊的链接指示说明。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被重新分配）， 直到所有关联这个文件的链接都删除掉。知道硬链接很重要，因为你可能有时 会遇到它们，但现在实际中更喜欢使用符号链接，下一步我们会讨论符号链接。 



符号链接

创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面， 它们和 Windows 的快捷方式差不多，当然，符号链接早于 Windows 的快捷方式很多年。

 一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。 



创建硬链接

现在，我们试着创建链接。首先是硬链接。我们创建一些关联我们数据文件的链接：

```
[me@linuxbox playground]$ ln fun fun-hard
[me@linuxbox playground]$ ln fun dir1/fun-hard
[me@linuxbox playground]$ ln fun dir2/fun-hard
```

现在，我们有四个文件”fun”的实例。看一下目录 playground 中的内容：

```
[me@linuxbox playground]$ ls -l
total 16
drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir1
drwxrwxr-x 2 me  me 4096 2008-01-14 16:17 dir2
-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun
-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard
```

注意到一件事，列表中，文件 fun 和 fun-hard 的第二个字段是”4”，这个数字 是文件”fun”的硬链接数目。你要记得一个文件至少有一个硬链接，因为文件 名就是由链接创建的。那么，我们怎样知道实际上 fun 和 fun-hard 是同一个文件呢？ 在这个例子里，ls 不是很有用。虽然我们能够看到 fun 和 fun-hard 文件大小一样 （第五字段），但我们的列表没有提供可靠的信息来确定（这两个文件一样）。 为了解决这个问题，我们更深入的研究一下。

当考虑到硬链接的时候，我们可以假设文件由两部分组成：包含文件内容的数据部分和持有文件名的名字部分 ，这将有助于我们理解这个概念。当我们创建文件硬链接的时候，实际上是为文件创建了额外的名字部分， 并且这些名字都关联到相同的数据部分。这时系统会分配一连串的磁盘块给所谓的索引节点，然后索引节点与文 件名字部分相关联。因此每一个硬链接都关系到一个具体的包含文件内容的索引节点。



ls 命令有一种方法，来展示（文件索引节点）的信息。在命令中加上”-i”选项：

```
[me@linuxbox playground]$ ls -li
total 16
12353539 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir1
12353540 drwxrwxr-x 2 me  me 4096  2008-01-14  16:17  dir2
12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun
12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun-hard
```

在这个版本的列表中，第一字段表示文件索引节点号，正如我们所见到的， fun 和 fun-hard 共享一样的索引节点号，这就证实这两个文件是同一个文件。



创建符号链接

建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。

符号链接的建立过程相似于创建硬链接：

```
[me@linuxbox playground]$ ln -s fun fun-sym
[me@linuxbox playground]$ ln -s ../fun dir1/fun-sym
[me@linuxbox playground]$ ln -s ../fun dir2/fun-sym
```

第一个例子相当直接，在 ln 命令中，简单地加上”-s”选项就可以创建一个符号链接， 而不是一个硬链接。下面两个例子又是怎样呢？ 记住，当我们创建一个符号链接 的时候，会建立一个目标文件在哪里和符号链接有关联的文本描述。如果我们看看 ls 命令的输出结果，比较容易理解。

```
[me@linuxbox playground]$ ls -l dir1
total 4
-rw-r--r-- 4 me  me 1650 2008-01-10 16:33 fun-hard
lrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -> ../fun
```

目录 dir1 中，fun-sym 的列表说明了它是一个符号链接，通过在第一字段中的首字符”l” 可知，并且它还指向”../fun”，也是正确的。相对于 fun-sym 的存储位置，fun 在它的 上一个目录。同时注意，符号链接文件的长度是6，这是字符串”../fun”所包含的字符数， 而不是符号链接所指向的文件长度。

除了普通文件，符号链接也能关联目录：

```
[me@linuxbox playground]$ ln -s dir1 dir1-sym
[me@linuxbox playground]$ ls -l
total 16
...省略
```



对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。 







command包括：可执行程序、shell内部命令、shell函数、命令别名这四种

type  command  显示命令类型

which  command   显示一个可执行程序的位置 ，其余的命令种类无效

help  command    得到shell内建命令的帮助文档

command  --help   显示命令的用法

man  command   显示程序手册页

手册页组织形式：

| 章节 | 内容                               |
| ---- | ---------------------------------- |
| 1    | 用户命令                           |
| 2    | 程序接口内核系统调用               |
| 3    | C 库函数程序接口                   |
| 4    | 特殊文件，比如说设备结点和驱动程序 |
| 5    | 文件格式                           |
| 6    | 游戏娱乐，如屏幕保护程序           |
| 7    | 其他方面                           |
| 8    | 系统管理员命令                     |

man  section  serch-term   指定相应的部分查阅  man 5  passwd

apropos +关键词  显示基于某个关键词的匹配项  输出结果每行的第一个字段是手册页的名字，第二个字段展示章节。 

whatis  command   显示非常简洁的命令说明

info  command  显示程序info条目  

| 命令              | 行为                                          |
| ----------------- | --------------------------------------------- |
| ?                 | 显示命令帮助                                  |
| PgUp or Backspace | 显示上一页                                    |
| PgDn or Space     | 显示下一页                                    |
| n                 | 下一个 - 显示下一个结点                       |
| p                 | 上一个 - 显示上一个结点                       |
| u                 | Up - 显示当前所显示结点的父结点，通常是个菜单 |
| Enter             | 激活光标位置下的超级链接                      |
| q                 | 退出                                          |

多个命令可以用;隔开  比如 command1；command2;command3

alias name = 'string' 创建命令别名

示例： alias  foo = 'cd  /usr;  ls;  cd-'

unalias name  删除别名

alias  查看系统环境中所有的别名



ls -l  /usr/bin  >  ls-output.txt 创建一个/usr/bin的ls命令的结果，重定向到ls-output.txt中输出 ，如果出现错误则不输出到ls-output.txt中，而且会清空该文件



```
[me@linuxbox ~]$ > ls-output.txt //快速清空该文件的一个技巧
```



```
[me@linuxbox ~]$ ls -l /usr/bin >> ls-output.txt //追加文件内容到后面，而不是开头重写。使用”>>“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。
```



标准错误重定向没有专用的重定向操作符。为了重定向标准错误，我们必须参考其文件描述符。 一个程序可以在几个编号的文件流中的任一个上产生输出。虽然我们已经将这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误和文件描述符2一样，我们用这种 表示法来重定向标准错误：

```
[me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
```



可能有这种情况，我们希望捕捉一个命令的所有输出到一个文件。为了完成这个，我们 必须同时重定向标准输出和标准错误。有两种方法来完成任务。第一个，传统的方法， 在旧版本 shell 中也有效： 

```
[me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
```

注意重定向的顺序安排非常重要。标准错误的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。上面的例子，

```
>ls-output.txt 2>&1
```

重定向标准错误到文件 ls-output.txt，但是如果命令顺序改为：

```
2>&1 >ls-output.txt
```

则标准错误定向到屏幕。



我们不想要一个命令的输出结果，只想把它们扔掉。这种情况 尤其适用于错误和状态信息。系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。为了隐瞒命令错误信息，我们这样做：

```
[me@linuxbox ~]$ ls -l /bin/usr 2> /dev/null
```



```
cat [file]  //cat 命令读取一个或多个文件，然后复制它们到标准输出
```

```
[me@linuxbox ~]$ cat > lazydog.txt  //创建一个叫lazydog的文件，并输入数据
```



```
command1 | command2  //命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。 使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入
```

```
[me@linuxbox ~]$ ls -l /usr/bin | less
```

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | less //起到过滤器的作用
```

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | less //unique删除重复行
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq -d| less //显示重复数据列表
```



```
[me@linuxbox ~]$ wc ls-output.txt  //打印行数、字数和字节数
7902 64566 503634 ls-output.txt
```

wc -l 只显示行数



grep pattern [file...] 打印匹配模式匹配到的内容

```
[me@linuxbox ~]$ ls /bin /usr/bin | sort | uniq | grep zip
bunzip2
bzip2
gunzip
...
```

grep 有一些方便的选项：”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。 



 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。

```
[me@linuxbox ~]$ head -n 5 ls-output.txt
total 343496
...
[me@linuxbox ~]$ tail -n 5 ls-output.txt
...
```



tail 有一个选项允许你实时地浏览文件。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。在以下的例子里，我们要查看目录/var/log 里面的信息文件。在 一些 Linux 发行版中，要求有超级用户权限才能阅读这些文件，因为文件/var/log/messages 可能包含安全信息。

```
[me@linuxbox ~]$ tail -f /var/log/messages
Feb 8 13:40:05 twin4 dhclient: DHCPACK from 192.168.1.1
....
```

使用”-f”选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 Ctrl-c。



tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。这里，我们重复执行一个先前的例子， 这次包含 tee 命令，在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt：

```
[me@linuxbox ~]$ ls /usr/bin | tee ls.txt | grep zip
bunzip2
bzip2
....
```



echo  something   打印something

```
[me@linuxbox ~]$ echo [[:upper:]]*
Desktop Documents Music Pictures Public Templates Videos
```

```
[me@linuxbox ~]$ echo D*
Desktop  Documents
```

```
[me@linuxbox ~]$ echo *s
Documents Pictures Templates Videos
```



波浪线字符(“~”)有特殊的含义。当它用在 一个单词的开头时，它会展开成指定用户的家目录名，如果没有指定用户名，则展开成当前用户的家目录：

```
[me@linuxbox ~]$ echo ~
/home/me
```

如果有用户”foo”这个帐号，那么：

```
[me@linuxbox ~]$ echo ~foo
/home/foo
```

shell 在展开中执行算数表达式。这允许我们把 shell 提示当作计算器来使用：

```
[me@linuxbox ~]$ echo $((2 + 2))
4
```

算术表达式展开使用这种格式：

```
$((expression))
```

| 操作符 | 说明                                                       |
| ------ | ---------------------------------------------------------- |
| +      | 加                                                         |
| -      | 减                                                         |
| *      | 乘                                                         |
| /      | 除（但是记住，因为展开只是支持整数除法，所以结果是整数。） |
| %      | 取余，只是简单的意味着，“余数”                             |
| **     | 取幂                                                       |

5的平方乘以3：

```
[me@linuxbox ~]$ echo $(($((5**2)) * 3))
75
```

花括号展开。通过它，你可以从一个包含花括号的模式中 创建多个文本字符串。这是一个例子：

```
[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
```

花括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。花括号表达式本身可 能包含一个由逗号分开的字符串列表，或者一系列的整数，或者单个的字符串。这种模式不能 嵌入空白字符。

```
[me@linuxbox ~]$ echo Number_{1..5}
Number_1  Number_2  Number_3  Number_4  Number_5
```

一系列以倒序排列的字母：

```
[me@linuxbox ~]$ echo {Z..A}
Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
```

花括号展开可以嵌套：

```
[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b
aA1b aA2b aB3b aB4b
```

常见的应用是，创建一系列的文件或目录列表。例如， 如果我们是摄影师，有大量的相片。我们想把这些相片按年月先后组织起来。首先， 我们要创建一系列以数值”年－月”形式命名的目录。通过这种方式，可以使目录名按照 年代顺序排列。我们可以手动键入整个目录列表，但是工作量太大了，并且易于出错。 反之，我们可以这样做：

```
[me@linuxbox ~]$ mkdir Pics
[me@linuxbox ~]$ cd Pics
[me@linuxbox Pics]$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
[me@linuxbox Pics]$ ls
2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
```

参数展开这个特性在 shell 脚本中比直接在命令行中更有用。 它的许多功能和系统存储小块数据，并给每块数据命名的能力有关系。许多像这样的小块数据， 更恰当的称呼应该是变量，可供你方便地检查它们。例如，叫做”USER”的变量包含你的 用户名。可以这样做来调用参数，并查看 USER 中的内容，：

```
[me@linuxbox ~]$ echo $USER
me
```

命令替换允许我们把一个命令的输出作为一个展开模式来使用：

```
[me@linuxbox ~]$ echo $(ls)
Desktop Documents ls-output.txt Music Pictures Public Templates
Videos
```

```
[me@linuxbox ~]$ ls -l $(which cp)
-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp
```

```
[me@linuxbox ~]$ echo The total is $100.00  //变量1没有定义
The total is 00.00
[me@linuxbox ~]$ echo this is a    test  //shell会自动切除多余空格
this is a test
```



使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复破损的文件名。

```
[me@linuxbox ~]$ ls -l "two words.txt"
-rw-rw-r-- 1 me   me   18 2008-02-20 13:03 two words.txt
[me@linuxbox ~]$ mv "two words.txt" two_words.txt
```





```
[me@linuxbox ~]$ echo $(cal)
February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
[me@linuxbox ~]$ echo "$(cal)"
February 2008
....
```

在第一个实例中，没有引用的命令替换导致命令行包含38个参数。在第二个例子中， 命令行只有一个参数，参数中包括嵌入的空格和换行符。



如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：

```
[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
text /home/me/ls-output.txt a b foo 4 me
[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
text ~/*.txt   {a,b} foo 4 me
[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
```



有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。

```
[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
The balance for user me is: $5.00
```



clear  清空屏幕

history  显示历史内容



键盘光标移动命令

| 按键   | 行动                                                   |
| ------ | ------------------------------------------------------ |
| Ctrl-a | 移动光标到行首。                                       |
| Ctrl-e | 移动光标到行尾。                                       |
| Ctrl-f | 光标前移一个字符；和右箭头作用一样。                   |
| Ctrl-b | 光标后移一个字符；和左箭头作用一样。                   |
| Alt-f  | 光标前移一个词。                                       |
| Alt-b  | 光标后移一个词。                                       |
| Ctrl-l | 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。 |

| 按键   | 行动                                     |
| ------ | ---------------------------------------- |
| Ctrl-d | 删除光标位置的字符。                     |
| Ctrl-t | 光标位置的字符和光标前面的字符互换位置。 |
| Alt-t  | 光标位置的字和其前面的字互换位置。       |
| Alt-l  | 把从光标位置到字尾的字符转换成小写字母。 |
| Alt-u  | 把从光标位置到字尾的字符转换成大写字母。 |

| 按键  | 行动                                                         |
| ----- | ------------------------------------------------------------ |
| Alt-? | 显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。 |
| Alt-* | 插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。 |



在默认情况下，bash 会存储你所输入的最后 500 个命令。可以调整这个数值。比方说我们想在自己曾经用过的命令中，找出和/usr/bin这一目录相关的。那么我们就可以这样做：

```
[me@linuxbox ~]$ history | grep /usr/bin
```

比方说在我们的搜索结果之中，我们得到一行，包含了有趣的命令，像这样；

```
88  ls -l /usr/bin > ls-output.txt
```

数字 “88” 是这个命令在历史列表中的行号。我们可以使用另一种叫做 历史命令展开的方式，来调用“88”所代表的这一行命令：

```
[me@linuxbox ~]$ !88
```



启动递增搜索， 输入 Ctrl-r，其后输入你要寻找的文本。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（向上移动历史列表）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。 

历史命令：

| 按键   | 行为                                                         |
| ------ | ------------------------------------------------------------ |
| Ctrl-p | 移动到上一个历史条目。类似于上箭头按键。                     |
| Ctrl-n | 移动到下一个历史条目。类似于下箭头按键。                     |
| Alt-<  | 移动到历史列表开头。                                         |
| Alt->  | 移动到历史列表结尾，即当前命令行。                           |
| Ctrl-r | 反向递增搜索。从当前命令行开始，向上递增搜索。               |
| Alt-p  | 反向搜索，不是递增顺序。输入要查找的字符串，然后按下 Enter，执行搜索。 |
| Alt-n  | 向前搜索，非递增顺序。                                       |
| Ctrl-o | 执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。 |

| 序列     | 行为                                                         |
| -------- | ------------------------------------------------------------ |
| !!       | 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 |
| !number  | 重复历史列表中第 number 行的命令。                           |
| !string  | 重复最近历史列表中，以这个字符串开头的命令。                 |
| !?string | 重复最近历史列表中，包含这个字符串的命令。                   |





- id – 显示用户身份号
- chmod – 更改文件模式
- umask – 设置默认的文件权限
- su – 以另一个用户的身份来运行 shell
- sudo – 以另一个用户的身份来执行命令
- chown – 更改文件所有者
- chgrp – 更改文件组所有权
- passwd – 更改用户密码



列表的前十个字符是文件的属性。这十个字符的第一个字符表明文件类型。下表是你可能经常看到 的文件类型（还有其它的，不常见类型）：

 

| 属性 | 文件类型                                                     |
| ---- | ------------------------------------------------------------ |
| -    | 一个普通文件                                                 |
| d    | 一个目录                                                     |
| l    | 一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 |
| c    | 一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器 |
| b    | 一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。 |

剩下的九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限。 

| 属性 | 文件                                                         | 目录                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| r    | 允许打开并读取文件内容。                                     | 允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。  |
| w    | 允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。 | 允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。 |
| x    | 允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。 | 允许进入目录，例如：cd directory 。                          |

通过使用3个八进制数字，我们能够设置文件所有者、用户组和其他人的权限：

```
[me@linuxbox ~]$ > foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw-rw-r-- 1 me    me    0  2008-03-06 14:52 foo.txt
[me@linuxbox ~]$ chmod 600 foo.txt
[me@linuxbox ~]$ ls -l foo.txt
-rw------- 1 me    me    0  2008-03-06 14:52 foo.txt
```



chmod 命令符号表示法 ：  u  “user”的缩写，是文件或者目录的所有者，g 用户组， o是“other”的简写，意思是其他所有的人，a是“all”的简写，是“u”“g”和“o”三者的组合



| u+x       | 为文件所有者添加可执行权限。                                 |
| --------- | ------------------------------------------------------------ |
| u-x       | 删除文件所有者的可执行权限。                                 |
| +x        | 为文件所有者，用户组，和其他所有人添加可执行权限。 等价于 a+x。 |
| o-rw      | 除了文件所有者和用户组，删除其他人的读权限和写权限。         |
| go=rw     | 给群组的主人和任意文件拥有者的人读写权限。如果群组的主人或全局之前已经有了执行的权限，他们将被移除。 |
| u+x,go=rw | 给文件拥有者执行权限并给组和其他人读和执行的权限。多种设定可以用逗号分开。 |

这里有一些例子，使用 chmod 命令和符号表示法，来设置这些特殊的权限。首先， 授予一个程序 setuid 权限。

*chmod u+s program*

下一步，授予一个目录 setgid 权限：

*chmod g+s dir*

最后，授予一个目录 sticky 权限：

*chmod +t dir*

当浏览 ls 命令的输出结果时，你可以确认这些特殊权限。这里有一些例子。首先，一个程序被设置为setuid属性：

*-rwsr-xr-x*

具有 setgid 属性的目录：

*drwxrwsr-x*

设置了 sticky 位的目录：

*drwxrwxrwt*



umask - 设置默认权限  掩码，默认是四个八进制数0000，000 000 000 000， 选1的位会被umask删除权限。第一位是 setuid 位（八进制4000）。当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。很明显，因为这会引起安全方面的问题，所有可以 设置 setuid 位的程序个数，必须控制在绝对小的范围内。 第二个是 setgid 位（八进制2000），这个相似于 setuid 位，把有效用户组 ID 从真正的 用户组 ID 更改为文件所有者的组 ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件 具有这个目录用户组的所有权，而不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。 第三个是 sticky 位（八进制1000）。这个继承于 Unix，在 Unix 中，它可能把一个可执行文件 标志为“不可交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。这个经常用来控制访问共享目录，比方说/tmp。 



su 命令用来以另一个用户的身份来启动 shell。这个命令语法看起来像这样：

```
su [-[l]] [user]
```

如果包含”-l”选项，那么会为指定用户启动一个需要登录的 shell。这意味着会加载此用户的 shell 环境， 并且工作目录会更改到这个用户的家目录。这通常是我们所需要的。如果不指定用户，那么就假定是 超级用户。注意（不可思议地），选项”-l”可以缩写为”-“，这是经常用到的形式。启动超级用户的 shell， 我们可以这样做：

```
[me@linuxbox ~]$ su -
Password:
[root@linuxbox ~]#
```

ubuntu第一次使用的时候：

1. $ sudo passwd root  
2. Enter new UNIX password:   
3. Retype new UNIX password:   
4. passwd: password updated successfully  

更改密码之后root账户才能拿到超级用户权限，否则直接用 sudo -i可以

按下回车符之后，shell 提示我们输入超级用户的密码。如果密码输入正确，出现一个新的 shell 提示符， 这表明这个 shell 具有超级用户特权（提示符的末尾字符是”#”而不是”$”），并且当前工作目录是超级用户的家目录 （通常是/root）。一旦进入一个新的 shell，我们能执行超级用户所使用的命令。当工作完成后， 输入”exit”，则返回到原来的 shell:

```
[root@linuxbox ~]# exit
[me@linuxbox ~]$
```



以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：

```
su -c 'command'
```

使用这种模式，命令传递到一个新 shell 中执行。把命令用单引号引起来很重要，因为我们不想 命令在我们的 shell 中展开，但需要在新 shell 中展开。

 sudo 命令可以授予哪些权限，使用”-l”选项，列出所有权限：

```
[me@linuxbox ~]$ sudo -l
User me may run the following commands on this host:
(ALL) ALL
```

chown 命令被用来更改文件或目录的所有者和用户组。使用这个命令需要超级用户权限。chown 命令 的语法看起来像这样：

```
chown [owner][:[group]] file...
```

| 参数      | 结果                                                         |
| --------- | ------------------------------------------------------------ |
| bob       | 把文件所有者从当前属主更改为用户 bob。                       |
| bob:users | 把文件所有者改为用户 bob，文件用户组改为用户组 users。       |
| :admins   | 把文件用户组改为组 admins，文件所有者不变。                  |
| bob:      | 文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。 |

chgrp - 更改用户组所有权

```
passwd [user] //更改用户密码
```

